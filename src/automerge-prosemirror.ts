import { PluginKey, Plugin, EditorState, Transaction } from "prosemirror-state"
import { DocHandle } from "automerge-repo"
import { patchToProsemirrorTransaction, prosemirrorTransactionToAutomerge } from "./prosemirrorToAutomerge"
import { Patch } from "@automerge/automerge"
export const automergePluginKey = new PluginKey(
  "automergeProsemirror"
)

export const automergePlugin = <T>(
  handle: DocHandle<T>,
  attribute: keyof T
) => {
  const changeDoc = handle.change.bind(handle)
  const plugin = new Plugin({
    key: automergePluginKey,
    state: {
      init(config, instance) {
        
      },
      apply(tr, value, oldState) {
        const meta = tr.getMeta(automergePluginKey)
        console.log("In apply", meta, tr)

        // Prevent an infinite loop:
        // don't create changes from transactions generated by a patch.
        if (meta && meta.isFromPatch) {
          return
        }

        prosemirrorTransactionToAutomerge(
          tr.steps,
          changeDoc,
          attribute,
          oldState
        )
      },
    },
  })

  return plugin
}

export function convertPatchToProsemirrorTransaction(tr: Transaction, patches: Patch[]): Transaction {
  tr.setMeta(automergePluginKey, { isFromPatch: true })
  patchToProsemirrorTransaction(tr, patches)
  return tr
}